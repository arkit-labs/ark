#!/bin/zsh

# @required module


#--------------------------------------------【 ztest 】
function ztest() {
    local src=${1:=.}
    local fx=(*_test.zsh)

    function searchfn() {

    }

    function testfn() {

    }

    for f in fx; do
    done
}

#--------------------------------------------[ COMMON FUNC ]
alias @doc='@doc.show "$@" && @doc.print '

#--------------------------------------------
#  AGENT FUNCTIONS
#--------------------------------------------
# @require: jq openssl
function bitrue.spot.config.save() {
@doc "
save bitrue agent config
--user      :
--spot-ak   : spot API ak
--spot-sk   : spot API sk
--out       : output dir
"
    zparseopts -A opts -D -E -- \
        -user:=opts     \
        -spot-ak:=opts  \
        -spot-sk:=opts  \
        -out:=opts
    # save to
    local out=$opts[--out]
    local user=$opts[--user]
    local spot_sk=$opts[--spot-sk]
    local spot_ak=$opts[--spot-ak]

    [[ -f $out ]] && error "the agent '$out' existed"

    local prefix=BITRUE
    local template="\
# Bitrue SPOT API SK
BITRUE_API_SPOT_AK=$spot_ak

# Bitrue SPOT API AK
BITRUE_API_SPOT_SK=$spot_sk
"
    print -n "${(e)template}" > $out
    chmod 600 $out
}


BITRUE_SPOT_API=https://openapi.bitrue.com
function bitrue.api.sign() {
    local s=$(print -n ${1} | openssl dgst -sha256 -hmac $BITRUE_API_SPOT_SK)
    print -n ${s/*= }
}

function bitrue.spot.order.list() {
@doc "
List the order of target \$market
OPTIONS:
    -o:     open orders
    -a:     all orders
    -d \$n: query date limit (e.g. 90d 1m)
"
    local markets=($argv)
    [[ -z $markets ]] && error "please set the market name"
    for m in $markets; do
        #bitrue.spot.api.trade $m
        bitrue.spot.api.allOrders $m
    done
}

function bitrue.api.params() {
    typeset -A map
    map=("${(@)argv}")
    map[timestamp]=$(bitrue.time)

    local r
    for k in ${(ko)map}; do
        v=$map[$k]
        r="$r&${k}=${v}"
    done
    r="${r#&}"
    r="${r}&signature=$(bitrue.api.sign $r)"
    print $r
}

function bitrue.spot.api.trade() {
@doc "
\$1:    market
return: [(market,),...]
"
    local market=$1
    local resp=$(bitrue.http.get api/v2/myTrades recvWindow 5000 symbol "${(U)market}")
    [[ $resp == '[]' ]] && return
    <<< $resp
    #| jq -r '.[] | [.id, .time, .symbol, .price, .qty, .isBuyer] | @tsv'
}

function bitrue.http.get() {
    local p=$1
    [[ -n $p ]] && shift
    params=$(bitrue.api.params "$argv[@]" )
    [[ -n $params ]] && params="?$params"

    local url="${BITRUE_SPOT_API}/$p$params"
    curl -s \
         -H "X-MBX-APIKEY: $BITRUE_API_SPOT_AK " \
         -X GET "$url"
}

function bitrue.api.ping() {
    curl -s ${BITRUE_SPOT_API}/api/v1/ping
}

function bitrue.time {
    curl -s ${BITRUE_SPOT_API}/api/v1/time | jq .serverTime
}

function bitrue.api.price() {
    local symbol=${1:=btcusdt}
    local ammount=${2:=1}
    local r=$(curl -s "${BITRUE_SPOT_API}/api/v1/ticker/price?symbol=${(U)symbol}" | jq -r .price)
    [[ $r == null ]] && print "0" && return
    expr="x=(${(q)r}*$ammount)/1; if(x<1) print 0; x"
    <<< $expr | bc -l
}

function bitrue.spot.api.order() {
    local market=${1}
    local resp=$(bitrue.http.get api/v1/order recvWindow 5000 symbol "${(U)market}")
    <<< $resp
}

function bitrue.spot.api.allOrders() {
    local market=$1
    local limit=${3:=100}
    local days=${2:=90}
    local range=($(date.range $days))

    function query() {
        local resp=$(bitrue.http.get api/v1/allOrders recvWindow 5000 symbol "${(U)market}" startTime "$1" endTime "$2")
        [[ $resp == *'"data":null'* ]] && return -1
        [[ $resp == "[]" ]] && return 0
        # TODO:
        # 1. 订单的AGE
        print $resp | jq -r '.[] | [.orderId, .time, .side[:1], .status[:3], .price, .executedQty, .cummulativeQuoteQty] | @tsv'
    }

    for x in $range; do
        r=(${(s=:=)x})
        query $r[1] $r[2]
    done
}

function bitrue.spot.api.openOrders() {
    local symbol=${1}
    local params=
    local resp=$(bitrue.http.get api/v1/openOrders)

}

# $1: the days before now
# $2: steps (default:28 day)
# return: [start_time:end_time ...]
function date.range() {
    let now=$(date +%s)
    let prv=${1:=28}
    let step=29
    let day=$((24*60*60))

    local xs=({$[$now-day*prv]..$now..$[$step*$day]})
    (( $xs[-1] < $now )) && xs+=$now
    let i=0
    for x in $xs[1,-2]; do
        i=$[i+1]
        print $xs[i]001:$xs[i+1]000
    done
}

function bitrue.exchangeInfo() {
    resp=$(curl -s "${BITRUE_SPOT_API}/api/v1/exchangeInfo")
    print $resp | jq .
}

function bitrue.api.order.list() {
    local symbol=${1:=ftmusdt}
    local limit=${3:=100}
    local days=${2:=60}
    local range=($(date.range $days))


    function query() {
        local startTime=$1
        local endTime=$2
        local params=$(bitrue.api.params recvWindow 5000 symbol ${(U)symbol} startTime $startTime endTime $endTime)
        x='''
{
    "symbol": "ACEUSDT",
    "orderId": "493450483729760256",
    "price": "13.1000000000000000",                 # 价格
    "origQty": "200.0000000000000000",              # 下单量
    "executedQty": "199.8000000000000000",          # 成交数量
    "cummulativeQuoteQty": "2617.3800000000000000", # 成交额
    "status": "FILLED",                             # 状态
    "type": "LIMIT",                                # 单子类型
    "side": "BUY",                                  # 方向
    "time": 1703379302514,
    "updateTime": 1703396228000,
}
    '''
        resp=$(curl -s \
            -H "X-MBX-APIKEY: $BITRUE_AKEY" \
            -X GET "${BITRUE_SPOT_API}/api/v1/allOrders?${params}")
        [[ $resp == *'"data":null'* ]] && return -1
        [[ $resp == "[]" ]] && return 0
        print $resp | jq  -r '.[] | [.orderId,.symbol,.side,.status,.price,.origQty,.executedQty,.cummulativeQuoteQty,(.updateTime|tonumber)-(.time|tonumber)] | @tsv'
    }
    for x in $range; do
        r=(${(s=:=)x})
        query $r[1] $r[2]
    done
}

#---------------------------------
#
#             A.R.K
#
#---------------------------------
ARK_HOME=~/.ark
ARK_AGENT=
ARK_AGENT_ID=
ARK_AGENT_UID=
ARK_AGENT_SUPPORTED=(bitrue.spot okx.spot) # supported agent type



typeset -A ARK_PRICE_SPOT_BITRUE
typeset -A ARK_ACCOUNT_BITRUE
typeset -U ARK_ACCOUNT_BITRUE_IDX

ARK_ACCOUNT_BITRUE_IDX=(FTM ALGO ACE)

function ark.state.reset() {
    ARK_ACCOUNT_BITRUE=()
    ARK_ACCOUNT_BITRUE_IDX=()
    ARK_PRICE_SPOT_BITRUE=()
}

function ark.sync() {
    ark.price.sync
    # update price
    local time=$(bitrue.time)
    local bitrue=("${(@f)$(bitrue.spot.price.usdt)}")
    for p in $bitrue; do
        xs=(${=p})
        # last | high | low
        ark.state.price_put $xs[1] $xs[2] $xs[3]
    done

    # update account
    ark.bitrue.account
}

function ark.state.price_put() {
    local id=$1
    local last=$2
    local high=$3
    local low=$4
    ARK_PRICE_SPOT_BITRUE[$id]=$last
}

# $1 : market or id
# $2 : total
# $3 : free
# $4 : lock
function ark.state.account_put() {
    local id=$1
    local total=$2
    local lock=$3
    local free=$4
    ARK_ACCOUNT_BITRUE[$id]=$total
}

# $1: id (BTC ftm)
function ark.state.account_get() {
    local id=$1
    local xs=$ARK_ACCOUNT_BITRUE[${(U)id}]
    print -n $xs
}

function ark.state.price_get() {
    local id=$1
    [[ $id == USDT ]] && print -n 1
    print -n $ARK_PRICE_SPOT_BITRUE[${(U)id}USDT]
}

function ark.bitrue.account() {
    local assets=("${(f@)$(bitrue.api.account)}")
    local sum=()
    local ulock ufree
    # market | locked | free | total
    for x in $assets; do
        xs=(${=x})
        id=$xs[1]
        price=$(ark.state.price_get $id)
        [[ -z $price ]] && price=0
        sum+="$price*$xs[4]"
        ark.state.account_put $id $xs[4] $xs[3] $xs[2]
        [[ $id == USDT ]] && {
            ulock=$xs[3]
            ufree=$xs[2]
        }
    done

    #print -l $sum
    local SUM=$(print -n "scale=2; (${(j:+:)sum})" | bc -l)
    print "total:$SUM free:$ufree lock:$ulock"
}

function ark.main() {
    # ark.sync
    bitrue.api.order.list ftmusdt 30 | ark.calc
    ark.head ftm
}

function ark.head() {
    local idx=(${1})
    for id in $idx; do
        v=$(ark.state.account_get $id)
        print $id $v $(bitrue.api.price ${id}USDT $v)
    done
}

function SUM() {
    print -n "${(j:+:)argv}" | bc -l
}

function SUMU() {
    print -n "scale=2;(${(j:+:)argv})/1" | bc -l
}

function ark.calc() {
    local order="$(<&0)"
    local bu=()
    local bv=()
    local su=()
    local sv=()

    function on_BUY_FILLED() {
        local v=$argv[7]
        local u=$argv[8]
        bu+=$u
        bv+=$v
    }

    function on_SELL_FILLED() {
        local v=$argv[7]
        local u=$argv[8]
        su+=$u
        sv+=$v
    }

    function on_SELL_NEW() {

    }

    function on_SELL_CANCELED() {

    }

    for x in "${(@f)order}"; do
        xs=(${=x})
        side=$xs[3]
        stat=$xs[4]
        on_${side}_${stat} $xs
    done
    print "SELL : $(SUMU $su) $(SUM $sv)"
    print "BUY  : $(SUMU $bu) $(SUM $bv)"
}

(
VERSION=0.0.1


function @doc.print() {
    print -u2 -- ${1#"\n"}
    exit 0
}

function @doc.show() {
    # command
    # subcommand
    # 1: argv is empty              -> 0
    [[ -z $argv ]] && return 0
    # 2: argv contains -h or --help -> 0
    return 1
}

# $1: message
# $2: exit code
function error() {
    print -u2 $1 && exit ${2:=1}
}
#-----------------------------------------------[ cmd.agent ]
function ark.cmd.agent() {
@doc "
list the agents ark supported
"
    local cmd=$1
    [[ -n $cmd ]] && shift
    ark.cmd.agent.$cmd "$@"
}

function ark.cmd.agent.add() {
@doc "
ark agent add \${agent-id} [bitrue | okx]
"
    local id=$1
    local agent=${(L)2}

    # check params
    [[ -z $id ]] && error "agent id must NOT EMPTY"
    [[ $id =~ '[a-zA-Z]+[a-zA-Z0-9]*' ]] || error "agent id format error"
    [[ -z $agent ]] && error "agent must NOT EMPTY"
    [[ -z $ARK_AGENT_SUPPORTED[(r)$agent] ]] && error "invalidate agent '$agent'"


    # 1. check the agent $user existed?
    local agent_id=${(L)id}@${agent}

    # 2. call agent create functions
    agent_dir=$ARK_HOME/agents
    [[ -d $agent_dir ]] || mkdir -p $agent_dir
    $agent.config.save --out $agent_dir/$agent_id $argv
}

function ark.cmd.agent.list() {
@doc "
list the ark agents
ark agent list \${agent-id}
"
    local agent_dir=$ARK_HOME/agents
    [[ -d $agent_dir ]] || print -u2 "no agents found : '$agent_dir'"

    for a in $agent_dir/*; do
        print $a
    done
}


function ark.cmd.agent.use() {
@doc "
ark agent use \$agent_id
"

}

function ark.cmd.agent.delete() {

}

#-----------------------------------------------[ cmd.order ]
function ark.cmd.order() {
@doc "
ark order
OPTIONS:

COMMANDS:
    list
"
    local cmd=$1
    [[ -n $cmd ]] && shift
    ark.cmd.order.$cmd "$@"
}

function ark.cmd.order.list() {
@doc "
$ ark order list \${agent_id}
List the orders of target agent
OPTIONS:

USEAGE:

"
    local agent_id=$ARK_AGENT

    [[ -z $agent_id ]] && error "Agent is EMPTY"

    local user=${agent_id%@*}
    local agent=${agent_id#*@}

    # 1. Load agent config
    config=$ARK_HOME/agents/$agent_id
    [[ -f $config ]] || error "agent DO NOT EXISTED('$config')"
    source $config

    # 2. Call agent API
    $agent.order.list "$@"
}
#-----------------------------------------------[ cmd.asset ]
function ark.cmd.asset() {

}

#-----------------------------------------------[ cmd.agent ]
function ark.cmd.agent.api() {
    @doc "
        \${agent}.order.list : List all orders
    "
}
#-----------------------------------------------[ cmd.config ]
function ark.cmd.config() {

}


# load the target module dir, the $mod_dir/@init file will be sourced, the other file will load as autoload functions
# @load $mod_dir
ARK_MOD=()
function @load() {
    local m=$1
    [[ -d $m ]] || return 0
    [[ $ARK_MOD[(r)$m] ]] && return 0

    # 1. source @init first
    [[ -f $m/@init ]] && source $m/@init

    # 2. add autoload functions
    #TESTME: $fpath contains space
    [[ -z $fpath[(r)$m] ]] && fpath=("$m" $fpath) && autoload -- $m/[^@]*(:t)
}

function ark.config.agent.path() {
@doc "
Get the agent config path by agent_id

PARAMS:
    \$1: agent_id   (e.g.: amas)
    \$2: agent_type (e.g.: bitrue)
"
    print -n "$ARK_HOME/agents/${(L)1}@${(L)2}"
}
#-----------------------------------------------[ cmd.test ]
function ark.cmd.test() {
    @load public
    price 1 2 3
    print $MOD_NAME
}

function ark.cmd.public() {
    @load $ARK/public
    price {1..20}
}

function ark.cmd.http() {
    @load $ARK/http
    #http.debug
    http.head "a" "111" "b" "222"
    http.get "$@"
    #http.method GET  "$@"
    #http.method POST "$@"
    #http.get $url h1=1 h2=2 h3=3 -- p1=1 p2=2
}

function main() {
@doc "
ark $VERSION is a toolkit for playing web3
OPTIONS:
    -a:--agent \$agent_id set the agent to use

COMMANDS:
    asset
    order
    config
    agent
    price
    help
"
    zparseopts -A opts -D -F -E -- {a,-agent}:=opts
    ARK_AGENT=${opts[-a]:=$opts[--agent]}
    ARK_AGENT_TYPE=
    ARK_AGENT_NAME=
    local cmd=$1
    [[ -n $cmd ]] && shift

    # CALL SUBCOMMAND
    ark.cmd.$cmd "$@"
    print $HTTP_DEBUG
}


ARK=$0:h
main "$@"
)
